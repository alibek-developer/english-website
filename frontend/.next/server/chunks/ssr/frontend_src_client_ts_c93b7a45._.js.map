{"version":3,"sources":["../../../../../frontend/src/client.ts"],"sourcesContent":["// Code generated by the Encore 1.51.6 client generator. DO NOT EDIT.\r\n\r\n// Disable eslint, jshint, and jslint for this file.\r\n/* eslint-disable */\r\n/* jshint ignore:start */\r\n/*jslint-disable*/\r\nimport type { CookieWithOptions } from \"encore.dev/api\";\r\n\r\n/**\r\n * BaseURL is the base URL for calling the Encore application's API.\r\n */\r\nexport type BaseURL = string\r\n\r\nexport const Local: BaseURL = \"http://localhost:4000\"\r\n\r\n/**\r\n * Environment returns a BaseURL for calling the cloud environment with the given name.\r\n */\r\nexport function Environment(name: string): BaseURL {\r\n    return `https://${name}-.encr.app`\r\n}\r\n\r\n/**\r\n * PreviewEnv returns a BaseURL for calling the preview environment with the given PR number.\r\n */\r\nexport function PreviewEnv(pr: number | string): BaseURL {\r\n    return Environment(`pr${pr}`)\r\n}\r\n\r\nconst BROWSER = typeof globalThis === \"object\" && (\"window\" in globalThis);\r\n\r\n/**\r\n * Client is an API client for the  Encore application.\r\n */\r\nexport class Client {\r\n    public readonly admin: admin.ServiceClient\r\n    public readonly contact: contact.ServiceClient\r\n    public readonly courses: courses.ServiceClient\r\n    public readonly student: student.ServiceClient\r\n    public readonly testimonials: testimonials.ServiceClient\r\n    private readonly options: ClientOptions\r\n    private readonly target: string\r\n\r\n\r\n    /**\r\n     * Creates a Client for calling the public and authenticated APIs of your Encore application.\r\n     *\r\n     * @param target  The target which the client should be configured to use. See Local and Environment for options.\r\n     * @param options Options for the client\r\n     */\r\n    constructor(target: BaseURL, options?: ClientOptions) {\r\n        this.target = target\r\n        this.options = options ?? {}\r\n        const base = new BaseClient(this.target, this.options)\r\n        this.admin = new admin.ServiceClient(base)\r\n        this.contact = new contact.ServiceClient(base)\r\n        this.courses = new courses.ServiceClient(base)\r\n        this.student = new student.ServiceClient(base)\r\n        this.testimonials = new testimonials.ServiceClient(base)\r\n    }\r\n\r\n    /**\r\n     * Creates a new Encore client with the given client options set.\r\n     *\r\n     * @param options Client options to set. They are merged with existing options.\r\n     **/\r\n    public with(options: ClientOptions): Client {\r\n        return new Client(this.target, {\r\n            ...this.options,\r\n            ...options,\r\n        })\r\n    }\r\n}\r\n\r\n/**\r\n * Import the auth handler to be able to derive the auth type\r\n */\r\nimport type { auth as auth_auth } from \"~backend/auth/auth\";\r\n\r\n/**\r\n * ClientOptions allows you to override any default behaviour within the generated Encore client.\r\n */\r\nexport interface ClientOptions {\r\n    /**\r\n     * By default the client will use the inbuilt fetch function for making the API requests.\r\n     * however you can override it with your own implementation here if you want to run custom\r\n     * code on each API request made or response received.\r\n     */\r\n    fetcher?: Fetcher\r\n\r\n    /** Default RequestInit to be used for the client */\r\n    requestInit?: Omit<RequestInit, \"headers\"> & { headers?: Record<string, string> }\r\n\r\n    /**\r\n     * Allows you to set the authentication data to be used for each\r\n     * request either by passing in a static object or by passing in\r\n     * a function which returns a new object for each request.\r\n     */\r\n    auth?: RequestType<typeof auth_auth> | AuthDataGenerator\r\n}\r\n\r\n/**\r\n * Import the endpoint handlers to derive the types for the client.\r\n */\r\nimport { addCourse as api_admin_add_course_addCourse } from \"~backend/admin/add_course\";\r\nimport { addHomework as api_admin_add_homework_addHomework } from \"~backend/admin/add_homework\";\r\nimport { addLesson as api_admin_add_lesson_addLesson } from \"~backend/admin/add_lesson\";\r\nimport { addVideo as api_admin_add_video_addVideo } from \"~backend/admin/add_video\";\r\nimport { getStats as api_admin_get_stats_getStats } from \"~backend/admin/get_stats\";\r\nimport { getStudents as api_admin_get_students_getStudents } from \"~backend/admin/get_students\";\r\nimport { login as api_admin_login_login } from \"~backend/admin/login\";\r\n\r\nexport namespace admin {\r\n\r\n    export class ServiceClient {\r\n        private baseClient: BaseClient\r\n\r\n        constructor(baseClient: BaseClient) {\r\n            this.baseClient = baseClient\r\n            this.addCourse = this.addCourse.bind(this)\r\n            this.addHomework = this.addHomework.bind(this)\r\n            this.addLesson = this.addLesson.bind(this)\r\n            this.addVideo = this.addVideo.bind(this)\r\n            this.getStats = this.getStats.bind(this)\r\n            this.getStudents = this.getStudents.bind(this)\r\n            this.login = this.login.bind(this)\r\n        }\r\n\r\n        public async addCourse(params: RequestType<typeof api_admin_add_course_addCourse>): Promise<ResponseType<typeof api_admin_add_course_addCourse>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/admin/course`, {method: \"POST\", body: JSON.stringify(params)})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_add_course_addCourse>\r\n        }\r\n\r\n        public async addHomework(params: RequestType<typeof api_admin_add_homework_addHomework>): Promise<ResponseType<typeof api_admin_add_homework_addHomework>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/admin/homework`, {method: \"POST\", body: JSON.stringify(params)})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_add_homework_addHomework>\r\n        }\r\n\r\n        public async addLesson(params: RequestType<typeof api_admin_add_lesson_addLesson>): Promise<ResponseType<typeof api_admin_add_lesson_addLesson>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/admin/lesson`, {method: \"POST\", body: JSON.stringify(params)})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_add_lesson_addLesson>\r\n        }\r\n\r\n        public async addVideo(params: RequestType<typeof api_admin_add_video_addVideo>): Promise<ResponseType<typeof api_admin_add_video_addVideo>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/admin/videos`, {method: \"POST\", body: JSON.stringify(params)})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_add_video_addVideo>\r\n        }\r\n\r\n        public async getStats(): Promise<ResponseType<typeof api_admin_get_stats_getStats>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/admin/stats`, {method: \"GET\", body: undefined})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_get_stats_getStats>\r\n        }\r\n\r\n        public async getStudents(): Promise<ResponseType<typeof api_admin_get_students_getStudents>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/admin/students`, {method: \"GET\", body: undefined})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_get_students_getStudents>\r\n        }\r\n\r\n        public async login(params: RequestType<typeof api_admin_login_login>): Promise<ResponseType<typeof api_admin_login_login>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/admin/login`, {method: \"POST\", body: JSON.stringify(params)})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_admin_login_login>\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport namespace auth {\r\n}\r\n\r\n/**\r\n * Import the endpoint handlers to derive the types for the client.\r\n */\r\nimport { submit as api_contact_submit_submit } from \"~backend/contact/submit\";\r\n\r\nexport namespace contact {\r\n\r\n    export class ServiceClient {\r\n        private baseClient: BaseClient\r\n\r\n        constructor(baseClient: BaseClient) {\r\n            this.baseClient = baseClient\r\n            this.submit = this.submit.bind(this)\r\n        }\r\n\r\n        /**\r\n         * Submits a contact form\r\n         */\r\n        public async submit(params: RequestType<typeof api_contact_submit_submit>): Promise<ResponseType<typeof api_contact_submit_submit>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/contact`, {method: \"POST\", body: JSON.stringify(params)})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_contact_submit_submit>\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Import the endpoint handlers to derive the types for the client.\r\n */\r\nimport { get as api_courses_get_get } from \"~backend/courses/get\";\r\nimport { list as api_courses_list_list } from \"~backend/courses/list\";\r\n\r\nexport namespace courses {\r\n\r\n    export class ServiceClient {\r\n        private baseClient: BaseClient\r\n\r\n        constructor(baseClient: BaseClient) {\r\n            this.baseClient = baseClient\r\n            this.get = this.get.bind(this)\r\n            this.list = this.list.bind(this)\r\n        }\r\n\r\n        /**\r\n         * Retrieves a specific course by ID\r\n         */\r\n        public async get(params: { id: string }): Promise<ResponseType<typeof api_courses_get_get>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/courses/${encodeURIComponent(params.id)}`, {method: \"GET\", body: undefined})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_courses_get_get>\r\n        }\r\n\r\n        /**\r\n         * Lists all available courses\r\n         */\r\n        public async list(): Promise<ResponseType<typeof api_courses_list_list>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/courses`, {method: \"GET\", body: undefined})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_courses_list_list>\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Import the endpoint handlers to derive the types for the client.\r\n */\r\nimport { enrollCourse as api_student_enroll_course_enrollCourse } from \"~backend/student/enroll_course\";\r\nimport { getDashboard as api_student_get_dashboard_getDashboard } from \"~backend/student/get_dashboard\";\r\nimport { submitHomework as api_student_submit_homework_submitHomework } from \"~backend/student/submit_homework\";\r\n\r\nexport namespace student {\r\n\r\n    export class ServiceClient {\r\n        private baseClient: BaseClient\r\n\r\n        constructor(baseClient: BaseClient) {\r\n            this.baseClient = baseClient\r\n            this.enrollCourse = this.enrollCourse.bind(this)\r\n            this.getDashboard = this.getDashboard.bind(this)\r\n            this.submitHomework = this.submitHomework.bind(this)\r\n        }\r\n\r\n        public async enrollCourse(params: RequestType<typeof api_student_enroll_course_enrollCourse>): Promise<ResponseType<typeof api_student_enroll_course_enrollCourse>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/student/enroll`, {method: \"POST\", body: JSON.stringify(params)})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_student_enroll_course_enrollCourse>\r\n        }\r\n\r\n        public async getDashboard(): Promise<ResponseType<typeof api_student_get_dashboard_getDashboard>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/student/dashboard`, {method: \"GET\", body: undefined})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_student_get_dashboard_getDashboard>\r\n        }\r\n\r\n        public async submitHomework(params: RequestType<typeof api_student_submit_homework_submitHomework>): Promise<ResponseType<typeof api_student_submit_homework_submitHomework>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/student/homework/submit`, {method: \"POST\", body: JSON.stringify(params)})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_student_submit_homework_submitHomework>\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Import the endpoint handlers to derive the types for the client.\r\n */\r\nimport { list as api_testimonials_list_list } from \"~backend/testimonials/list\";\r\n\r\nexport namespace testimonials {\r\n\r\n    export class ServiceClient {\r\n        private baseClient: BaseClient\r\n\r\n        constructor(baseClient: BaseClient) {\r\n            this.baseClient = baseClient\r\n            this.list = this.list.bind(this)\r\n        }\r\n\r\n        /**\r\n         * Lists all testimonials\r\n         */\r\n        public async list(): Promise<ResponseType<typeof api_testimonials_list_list>> {\r\n            // Now make the actual call to the API\r\n            const resp = await this.baseClient.callTypedAPI(`/testimonials`, {method: \"GET\", body: undefined})\r\n            return JSON.parse(await resp.text(), dateReviver) as ResponseType<typeof api_testimonials_list_list>\r\n        }\r\n    }\r\n}\r\n\r\n\r\ntype PickMethods<Type> = Omit<CallParameters, \"method\"> & { method?: Type };\r\n\r\n// Helper type to omit all fields that are cookies.\r\ntype OmitCookie<T> = {\r\n  [K in keyof T as T[K] extends CookieWithOptions<any> ? never : K]: T[K];\r\n};\r\n\r\ntype RequestType<Type extends (...args: any[]) => any> =\r\n  Parameters<Type> extends [infer H, ...any[]]\r\n    ? OmitCookie<H>\r\n    : void;\r\n\r\ntype ResponseType<Type extends (...args: any[]) => any> = OmitCookie<Awaited<ReturnType<Type>>>;\r\n\r\nfunction dateReviver(key: string, value: any): any {\r\n  if (\r\n    typeof value === \"string\" &&\r\n    value.length >= 10 &&\r\n    value.charCodeAt(0) >= 48 && // '0'\r\n    value.charCodeAt(0) <= 57 // '9'\r\n  ) {\r\n    const parsedDate = new Date(value);\r\n    if (!isNaN(parsedDate.getTime())) {\r\n      return parsedDate;\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\n\r\nfunction encodeQuery(parts: Record<string, string | string[]>): string {\r\n    const pairs: string[] = []\r\n    for (const key in parts) {\r\n        const val = (Array.isArray(parts[key]) ?  parts[key] : [parts[key]]) as string[]\r\n        for (const v of val) {\r\n            pairs.push(`${key}=${encodeURIComponent(v)}`)\r\n        }\r\n    }\r\n    return pairs.join(\"&\")\r\n}\r\n\r\n// makeRecord takes a record and strips any undefined values from it,\r\n// and returns the same record with a narrower type.\r\n// @ts-ignore - TS ignore because makeRecord is not always used\r\nfunction makeRecord<K extends string | number | symbol, V>(record: Record<K, V | undefined>): Record<K, V> {\r\n    for (const key in record) {\r\n        if (record[key] === undefined) {\r\n            delete record[key]\r\n        }\r\n    }\r\n    return record as Record<K, V>\r\n}\r\n\r\nimport {\r\n  StreamInOutHandlerFn,\r\n  StreamInHandlerFn,\r\n  StreamOutHandlerFn,\r\n} from \"encore.dev/api\";\r\n\r\ntype StreamRequest<Type> = Type extends\r\n  | StreamInOutHandlerFn<any, infer Req, any>\r\n  | StreamInHandlerFn<any, infer Req, any>\r\n  | StreamOutHandlerFn<any, any>\r\n  ? Req\r\n  : never;\r\n\r\ntype StreamResponse<Type> = Type extends\r\n  | StreamInOutHandlerFn<any, any, infer Resp>\r\n  | StreamInHandlerFn<any, any, infer Resp>\r\n  | StreamOutHandlerFn<any, infer Resp>\r\n  ? Resp\r\n  : never;\r\n\r\n\r\nfunction encodeWebSocketHeaders(headers: Record<string, string>) {\r\n    // url safe, no pad\r\n    const base64encoded = btoa(JSON.stringify(headers))\r\n      .replaceAll(\"=\", \"\")\r\n      .replaceAll(\"+\", \"-\")\r\n      .replaceAll(\"/\", \"_\");\r\n    return \"encore.dev.headers.\" + base64encoded;\r\n}\r\n\r\nclass WebSocketConnection {\r\n    public ws: WebSocket;\r\n\r\n    private hasUpdateHandlers: (() => void)[] = [];\r\n\r\n    constructor(url: string, headers?: Record<string, string>) {\r\n        let protocols = [\"encore-ws\"];\r\n        if (headers) {\r\n            protocols.push(encodeWebSocketHeaders(headers))\r\n        }\r\n\r\n        this.ws = new WebSocket(url, protocols)\r\n\r\n        this.on(\"error\", () => {\r\n            this.resolveHasUpdateHandlers();\r\n        });\r\n\r\n        this.on(\"close\", () => {\r\n            this.resolveHasUpdateHandlers();\r\n        });\r\n    }\r\n\r\n    resolveHasUpdateHandlers() {\r\n        const handlers = this.hasUpdateHandlers;\r\n        this.hasUpdateHandlers = [];\r\n\r\n        for (const handler of handlers) {\r\n            handler()\r\n        }\r\n    }\r\n\r\n    async hasUpdate() {\r\n        // await until a new message have been received, or the socket is closed\r\n        await new Promise((resolve) => {\r\n            this.hasUpdateHandlers.push(() => resolve(null))\r\n        });\r\n    }\r\n\r\n    on(type: \"error\" | \"close\" | \"message\" | \"open\", handler: (event: any) => void) {\r\n        this.ws.addEventListener(type, handler);\r\n    }\r\n\r\n    off(type: \"error\" | \"close\" | \"message\" | \"open\", handler: (event: any) => void) {\r\n        this.ws.removeEventListener(type, handler);\r\n    }\r\n\r\n    close() {\r\n        this.ws.close();\r\n    }\r\n}\r\n\r\nexport class StreamInOut<Request, Response> {\r\n    public socket: WebSocketConnection;\r\n    private buffer: Response[] = [];\r\n\r\n    constructor(url: string, headers?: Record<string, string>) {\r\n        this.socket = new WebSocketConnection(url, headers);\r\n        this.socket.on(\"message\", (event: any) => {\r\n            this.buffer.push(JSON.parse(event.data, dateReviver));\r\n            this.socket.resolveHasUpdateHandlers();\r\n        });\r\n    }\r\n\r\n    close() {\r\n        this.socket.close();\r\n    }\r\n\r\n    async send(msg: Request) {\r\n        if (this.socket.ws.readyState === WebSocket.CONNECTING) {\r\n            // await that the socket is opened\r\n            await new Promise((resolve) => {\r\n                this.socket.ws.addEventListener(\"open\", resolve, { once: true });\r\n            });\r\n        }\r\n\r\n        return this.socket.ws.send(JSON.stringify(msg));\r\n    }\r\n\r\n    async next(): Promise<Response | undefined> {\r\n        for await (const next of this) return next;\r\n        return undefined;\r\n    }\r\n\r\n    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {\r\n        while (true) {\r\n            if (this.buffer.length > 0) {\r\n                yield this.buffer.shift() as Response;\r\n            } else {\r\n                if (this.socket.ws.readyState === WebSocket.CLOSED) return;\r\n                await this.socket.hasUpdate();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class StreamIn<Response> {\r\n    public socket: WebSocketConnection;\r\n    private buffer: Response[] = [];\r\n\r\n    constructor(url: string, headers?: Record<string, string>) {\r\n        this.socket = new WebSocketConnection(url, headers);\r\n        this.socket.on(\"message\", (event: any) => {\r\n            this.buffer.push(JSON.parse(event.data, dateReviver));\r\n            this.socket.resolveHasUpdateHandlers();\r\n        });\r\n    }\r\n\r\n    close() {\r\n        this.socket.close();\r\n    }\r\n\r\n    async next(): Promise<Response | undefined> {\r\n        for await (const next of this) return next;\r\n        return undefined;\r\n    }\r\n\r\n    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {\r\n        while (true) {\r\n            if (this.buffer.length > 0) {\r\n                yield this.buffer.shift() as Response;\r\n            } else {\r\n                if (this.socket.ws.readyState === WebSocket.CLOSED) return;\r\n                await this.socket.hasUpdate();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class StreamOut<Request, Response> {\r\n    public socket: WebSocketConnection;\r\n    private responseValue: Promise<Response>;\r\n\r\n    constructor(url: string, headers?: Record<string, string>) {\r\n        let responseResolver: (_: any) => void;\r\n        this.responseValue = new Promise((resolve) => responseResolver = resolve);\r\n\r\n        this.socket = new WebSocketConnection(url, headers);\r\n        this.socket.on(\"message\", (event: any) => {\r\n            responseResolver(JSON.parse(event.data, dateReviver))\r\n        });\r\n    }\r\n\r\n    async response(): Promise<Response> {\r\n        return this.responseValue;\r\n    }\r\n\r\n    close() {\r\n        this.socket.close();\r\n    }\r\n\r\n    async send(msg: Request) {\r\n        if (this.socket.ws.readyState === WebSocket.CONNECTING) {\r\n            // await that the socket is opened\r\n            await new Promise((resolve) => {\r\n                this.socket.ws.addEventListener(\"open\", resolve, { once: true });\r\n            });\r\n        }\r\n\r\n        return this.socket.ws.send(JSON.stringify(msg));\r\n    }\r\n}\r\n// CallParameters is the type of the parameters to a method call, but require headers to be a Record type\r\ntype CallParameters = Omit<RequestInit, \"headers\"> & {\r\n    /** Headers to be sent with the request */\r\n    headers?: Record<string, string>\r\n\r\n    /** Query parameters to be sent with the request */\r\n    query?: Record<string, string | string[]>\r\n}\r\n\r\n// AuthDataGenerator is a function that returns a new instance of the authentication data required by this API\r\nexport type AuthDataGenerator = () =>\r\n  | RequestType<typeof auth_auth>\r\n  | Promise<RequestType<typeof auth_auth> | undefined>\r\n  | undefined;\r\n\r\n// A fetcher is the prototype for the inbuilt Fetch function\r\nexport type Fetcher = typeof fetch;\r\n\r\nconst boundFetch = fetch.bind(this);\r\n\r\nclass BaseClient {\r\n    readonly baseURL: string\r\n    readonly fetcher: Fetcher\r\n    readonly headers: Record<string, string>\r\n    readonly requestInit: Omit<RequestInit, \"headers\"> & { headers?: Record<string, string> }\r\n    readonly authGenerator?: AuthDataGenerator\r\n\r\n    constructor(baseURL: string, options: ClientOptions) {\r\n        this.baseURL = baseURL\r\n        this.headers = {}\r\n\r\n        // Add User-Agent header if the script is running in the server\r\n        // because browsers do not allow setting User-Agent headers to requests\r\n        if (!BROWSER) {\r\n            this.headers[\"User-Agent\"] = \"-Generated-TS-Client (Encore/1.51.6)\";\r\n        }\r\n\r\n        this.requestInit = options.requestInit ?? {};\r\n\r\n        // Setup what fetch function we'll be using in the base client\r\n        if (options.fetcher !== undefined) {\r\n            this.fetcher = options.fetcher\r\n        } else {\r\n            this.fetcher = boundFetch\r\n        }\r\n\r\n        // Setup an authentication data generator using the auth data token option\r\n        if (options.auth !== undefined) {\r\n            const auth = options.auth\r\n            if (typeof auth === \"function\") {\r\n                this.authGenerator = auth\r\n            } else {\r\n                this.authGenerator = () => auth\r\n            }\r\n        }\r\n    }\r\n\r\n    async getAuthData(): Promise<CallParameters | undefined> {\r\n        let authData: RequestType<typeof auth_auth> | undefined;\r\n\r\n        // If authorization data generator is present, call it and add the returned data to the request\r\n        if (this.authGenerator) {\r\n            const mayBePromise = this.authGenerator();\r\n            if (mayBePromise instanceof Promise) {\r\n                authData = await mayBePromise;\r\n            } else {\r\n                authData = mayBePromise;\r\n            }\r\n        }\r\n\r\n        if (authData) {\r\n            const data: CallParameters = {};\r\n\r\n            data.headers = makeRecord<string, string>({\r\n                authorization: authData.authorization,\r\n            });\r\n\r\n            return data;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    // createStreamInOut sets up a stream to a streaming API endpoint.\r\n    async createStreamInOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamInOut<Request, Response>> {\r\n        let { query, headers } = params ?? {};\r\n\r\n        // Fetch auth data if there is any\r\n        const authData = await this.getAuthData();\r\n\r\n        // If we now have authentication data, add it to the request\r\n        if (authData) {\r\n            if (authData.query) {\r\n                query = {...query, ...authData.query};\r\n            }\r\n            if (authData.headers) {\r\n                headers = {...headers, ...authData.headers};\r\n            }\r\n        }\r\n\r\n        const queryString = query ? '?' + encodeQuery(query) : ''\r\n        return new StreamInOut(this.baseURL + path + queryString, headers);\r\n    }\r\n\r\n    // createStreamIn sets up a stream to a streaming API endpoint.\r\n    async createStreamIn<Response>(path: string, params?: CallParameters): Promise<StreamIn<Response>> {\r\n        let { query, headers } = params ?? {};\r\n\r\n        // Fetch auth data if there is any\r\n        const authData = await this.getAuthData();\r\n\r\n        // If we now have authentication data, add it to the request\r\n        if (authData) {\r\n            if (authData.query) {\r\n                query = {...query, ...authData.query};\r\n            }\r\n            if (authData.headers) {\r\n                headers = {...headers, ...authData.headers};\r\n            }\r\n        }\r\n\r\n        const queryString = query ? '?' + encodeQuery(query) : ''\r\n        return new StreamIn(this.baseURL + path + queryString, headers);\r\n    }\r\n\r\n    // createStreamOut sets up a stream to a streaming API endpoint.\r\n    async createStreamOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamOut<Request, Response>> {\r\n        let { query, headers } = params ?? {};\r\n\r\n        // Fetch auth data if there is any\r\n        const authData = await this.getAuthData();\r\n\r\n        // If we now have authentication data, add it to the request\r\n        if (authData) {\r\n            if (authData.query) {\r\n                query = {...query, ...authData.query};\r\n            }\r\n            if (authData.headers) {\r\n                headers = {...headers, ...authData.headers};\r\n            }\r\n        }\r\n\r\n        const queryString = query ? '?' + encodeQuery(query) : ''\r\n        return new StreamOut(this.baseURL + path + queryString, headers);\r\n    }\r\n\r\n    // callTypedAPI makes an API call, defaulting content type to \"application/json\"\r\n    public async callTypedAPI(path: string, params?: CallParameters): Promise<Response> {\r\n        return this.callAPI(path, {\r\n            ...params,\r\n            headers: { \"Content-Type\": \"application/json\", ...params?.headers }\r\n        });\r\n    }\r\n\r\n    // callAPI is used by each generated API method to actually make the request\r\n    public async callAPI(path: string, params?: CallParameters): Promise<Response> {\r\n        let { query, headers, ...rest } = params ?? {}\r\n        const init = {\r\n            ...this.requestInit,\r\n            ...rest,\r\n        }\r\n\r\n        // Merge our headers with any predefined headers\r\n        init.headers = {...this.headers, ...init.headers, ...headers}\r\n\r\n        // Fetch auth data if there is any\r\n        const authData = await this.getAuthData();\r\n\r\n        // If we now have authentication data, add it to the request\r\n        if (authData) {\r\n            if (authData.query) {\r\n                query = {...query, ...authData.query};\r\n            }\r\n            if (authData.headers) {\r\n                init.headers = {...init.headers, ...authData.headers};\r\n            }\r\n        }\r\n\r\n        // Make the actual request\r\n        const queryString = query ? '?' + encodeQuery(query) : ''\r\n        const response = await this.fetcher(this.baseURL+path+queryString, init)\r\n\r\n        // handle any error responses\r\n        if (!response.ok) {\r\n            // try and get the error message from the response body\r\n            let body: APIErrorResponse = { code: ErrCode.Unknown, message: `request failed: status ${response.status}` }\r\n\r\n            // if we can get the structured error we should, otherwise give a best effort\r\n            try {\r\n                const text = await response.text()\r\n\r\n                try {\r\n                    const jsonBody = JSON.parse(text)\r\n                    if (isAPIErrorResponse(jsonBody)) {\r\n                        body = jsonBody\r\n                    } else {\r\n                        body.message += \": \" + JSON.stringify(jsonBody)\r\n                    }\r\n                } catch {\r\n                    body.message += \": \" + text\r\n                }\r\n            } catch (e) {\r\n                // otherwise we just append the text to the error message\r\n                body.message += \": \" + String(e)\r\n            }\r\n\r\n            throw new APIError(response.status, body)\r\n        }\r\n\r\n        return response\r\n    }\r\n}\r\n\r\n/**\r\n * APIErrorDetails represents the response from an Encore API in the case of an error\r\n */\r\ninterface APIErrorResponse {\r\n    code: ErrCode\r\n    message: string\r\n    details?: any\r\n}\r\n\r\nfunction isAPIErrorResponse(err: any): err is APIErrorResponse {\r\n    return (\r\n        err !== undefined && err !== null &&\r\n        isErrCode(err.code) &&\r\n        typeof(err.message) === \"string\" &&\r\n        (err.details === undefined || err.details === null || typeof(err.details) === \"object\")\r\n    )\r\n}\r\n\r\nfunction isErrCode(code: any): code is ErrCode {\r\n    return code !== undefined && Object.values(ErrCode).includes(code)\r\n}\r\n\r\n/**\r\n * APIError represents a structured error as returned from an Encore application.\r\n */\r\nexport class APIError extends Error {\r\n    /**\r\n     * The HTTP status code associated with the error.\r\n     */\r\n    public readonly status: number\r\n\r\n    /**\r\n     * The Encore error code\r\n     */\r\n    public readonly code: ErrCode\r\n\r\n    /**\r\n     * The error details\r\n     */\r\n    public readonly details?: any\r\n\r\n    constructor(status: number, response: APIErrorResponse) {\r\n        // extending errors causes issues after you construct them, unless you apply the following fixes\r\n        super(response.message);\r\n\r\n        // set error name as constructor name, make it not enumerable to keep native Error behavior\r\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors\r\n        Object.defineProperty(this, 'name', {\r\n            value:        'APIError',\r\n            enumerable:   false,\r\n            configurable: true,\r\n        })\r\n\r\n        // fix the prototype chain\r\n        if ((Object as any).setPrototypeOf == undefined) {\r\n            (this as any).__proto__ = APIError.prototype\r\n        } else {\r\n            Object.setPrototypeOf(this, APIError.prototype);\r\n        }\r\n\r\n        // capture a stack trace\r\n        if ((Error as any).captureStackTrace !== undefined) {\r\n            (Error as any).captureStackTrace(this, this.constructor);\r\n        }\r\n\r\n        this.status = status\r\n        this.code = response.code\r\n        this.details = response.details\r\n    }\r\n}\r\n\r\n/**\r\n * Typeguard allowing use of an APIError's fields'\r\n */\r\nexport function isAPIError(err: any): err is APIError {\r\n    return err instanceof APIError;\r\n}\r\n\r\nexport enum ErrCode {\r\n    /**\r\n     * OK indicates the operation was successful.\r\n     */\r\n    OK = \"ok\",\r\n\r\n    /**\r\n     * Canceled indicates the operation was canceled (typically by the caller).\r\n     *\r\n     * Encore will generate this error code when cancellation is requested.\r\n     */\r\n    Canceled = \"canceled\",\r\n\r\n    /**\r\n     * Unknown error. An example of where this error may be returned is\r\n     * if a Status value received from another address space belongs to\r\n     * an error-space that is not known in this address space. Also\r\n     * errors raised by APIs that do not return enough error information\r\n     * may be converted to this error.\r\n     *\r\n     * Encore will generate this error code in the above two mentioned cases.\r\n     */\r\n    Unknown = \"unknown\",\r\n\r\n    /**\r\n     * InvalidArgument indicates client specified an invalid argument.\r\n     * Note that this differs from FailedPrecondition. It indicates arguments\r\n     * that are problematic regardless of the state of the system\r\n     * (e.g., a malformed file name).\r\n     *\r\n     * This error code will not be generated by the gRPC framework.\r\n     */\r\n    InvalidArgument = \"invalid_argument\",\r\n\r\n    /**\r\n     * DeadlineExceeded means operation expired before completion.\r\n     * For operations that change the state of the system, this error may be\r\n     * returned even if the operation has completed successfully. For\r\n     * example, a successful response from a server could have been delayed\r\n     * long enough for the deadline to expire.\r\n     *\r\n     * The gRPC framework will generate this error code when the deadline is\r\n     * exceeded.\r\n     */\r\n    DeadlineExceeded = \"deadline_exceeded\",\r\n\r\n    /**\r\n     * NotFound means some requested entity (e.g., file or directory) was\r\n     * not found.\r\n     *\r\n     * This error code will not be generated by the gRPC framework.\r\n     */\r\n    NotFound = \"not_found\",\r\n\r\n    /**\r\n     * AlreadyExists means an attempt to create an entity failed because one\r\n     * already exists.\r\n     *\r\n     * This error code will not be generated by the gRPC framework.\r\n     */\r\n    AlreadyExists = \"already_exists\",\r\n\r\n    /**\r\n     * PermissionDenied indicates the caller does not have permission to\r\n     * execute the specified operation. It must not be used for rejections\r\n     * caused by exhausting some resource (use ResourceExhausted\r\n     * instead for those errors). It must not be\r\n     * used if the caller cannot be identified (use Unauthenticated\r\n     * instead for those errors).\r\n     *\r\n     * This error code will not be generated by the gRPC core framework,\r\n     * but expect authentication middleware to use it.\r\n     */\r\n    PermissionDenied = \"permission_denied\",\r\n\r\n    /**\r\n     * ResourceExhausted indicates some resource has been exhausted, perhaps\r\n     * a per-user quota, or perhaps the entire file system is out of space.\r\n     *\r\n     * This error code will be generated by the gRPC framework in\r\n     * out-of-memory and server overload situations, or when a message is\r\n     * larger than the configured maximum size.\r\n     */\r\n    ResourceExhausted = \"resource_exhausted\",\r\n\r\n    /**\r\n     * FailedPrecondition indicates operation was rejected because the\r\n     * system is not in a state required for the operation's execution.\r\n     * For example, directory to be deleted may be non-empty, an rmdir\r\n     * operation is applied to a non-directory, etc.\r\n     *\r\n     * A litmus test that may help a service implementor in deciding\r\n     * between FailedPrecondition, Aborted, and Unavailable:\r\n     *  (a) Use Unavailable if the client can retry just the failing call.\r\n     *  (b) Use Aborted if the client should retry at a higher-level\r\n     *      (e.g., restarting a read-modify-write sequence).\r\n     *  (c) Use FailedPrecondition if the client should not retry until\r\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\r\n     *      fails because the directory is non-empty, FailedPrecondition\r\n     *      should be returned since the client should not retry unless\r\n     *      they have first fixed up the directory by deleting files from it.\r\n     *  (d) Use FailedPrecondition if the client performs conditional\r\n     *      REST Get/Update/Delete on a resource and the resource on the\r\n     *      server does not match the condition. E.g., conflicting\r\n     *      read-modify-write on the same resource.\r\n     *\r\n     * This error code will not be generated by the gRPC framework.\r\n     */\r\n    FailedPrecondition = \"failed_precondition\",\r\n\r\n    /**\r\n     * Aborted indicates the operation was aborted, typically due to a\r\n     * concurrency issue like sequencer check failures, transaction aborts,\r\n     * etc.\r\n     *\r\n     * See litmus test above for deciding between FailedPrecondition,\r\n     * Aborted, and Unavailable.\r\n     */\r\n    Aborted = \"aborted\",\r\n\r\n    /**\r\n     * OutOfRange means operation was attempted past the valid range.\r\n     * E.g., seeking or reading past end of file.\r\n     *\r\n     * Unlike InvalidArgument, this error indicates a problem that may\r\n     * be fixed if the system state changes. For example, a 32-bit file\r\n     * system will generate InvalidArgument if asked to read at an\r\n     * offset that is not in the range [0,2^32-1], but it will generate\r\n     * OutOfRange if asked to read from an offset past the current\r\n     * file size.\r\n     *\r\n     * There is a fair bit of overlap between FailedPrecondition and\r\n     * OutOfRange. We recommend using OutOfRange (the more specific\r\n     * error) when it applies so that callers who are iterating through\r\n     * a space can easily look for an OutOfRange error to detect when\r\n     * they are done.\r\n     *\r\n     * This error code will not be generated by the gRPC framework.\r\n     */\r\n    OutOfRange = \"out_of_range\",\r\n\r\n    /**\r\n     * Unimplemented indicates operation is not implemented or not\r\n     * supported/enabled in this service.\r\n     *\r\n     * This error code will be generated by the gRPC framework. Most\r\n     * commonly, you will see this error code when a method implementation\r\n     * is missing on the server. It can also be generated for unknown\r\n     * compression algorithms or a disagreement as to whether an RPC should\r\n     * be streaming.\r\n     */\r\n    Unimplemented = \"unimplemented\",\r\n\r\n    /**\r\n     * Internal errors. Means some invariants expected by underlying\r\n     * system has been broken. If you see one of these errors,\r\n     * something is very broken.\r\n     *\r\n     * This error code will be generated by the gRPC framework in several\r\n     * internal error conditions.\r\n     */\r\n    Internal = \"internal\",\r\n\r\n    /**\r\n     * Unavailable indicates the service is currently unavailable.\r\n     * This is a most likely a transient condition and may be corrected\r\n     * by retrying with a backoff. Note that it is not always safe to retry\r\n     * non-idempotent operations.\r\n     *\r\n     * See litmus test above for deciding between FailedPrecondition,\r\n     * Aborted, and Unavailable.\r\n     *\r\n     * This error code will be generated by the gRPC framework during\r\n     * abrupt shutdown of a server process or network connection.\r\n     */\r\n    Unavailable = \"unavailable\",\r\n\r\n    /**\r\n     * DataLoss indicates unrecoverable data loss or corruption.\r\n     *\r\n     * This error code will not be generated by the gRPC framework.\r\n     */\r\n    DataLoss = \"data_loss\",\r\n\r\n    /**\r\n     * Unauthenticated indicates the request does not have valid\r\n     * authentication credentials for the operation.\r\n     *\r\n     * The gRPC framework will generate this error code when the\r\n     * authentication metadata is invalid or a Credentials callback fails,\r\n     * but also expect authentication middleware to generate it.\r\n     */\r\n    Unauthenticated = \"unauthenticated\",\r\n}\r\n\r\nconst ENCORE_BASE_URL: BaseURL =\r\n  import.meta.env.VITE_API_URL ||\r\n  import.meta.env.VITE_API_BASE_URL ||\r\n  import.meta.env.VITE_CLIENT_TARGET ||\r\n  Local;\r\n\r\nexport default new Client(ENCORE_BASE_URL, {\r\n  requestInit: { credentials: \"include\" },\r\n});\r\n"],"names":[],"mappings":"uCAKgB,IAAA,EAAA,6DAwBV,EAAgC,UAAtB,OAAO,YAA4B,WAAY,UAKxD,OAAM,EACO,KAA0B,CAC1B,OAA8B,CAC9B,OAA8B,CAC9B,OAA8B,CAC9B,YAAwC,AACvC,QAAsB,CACtB,MAAc,AAS/B,aAAY,CAAe,CAAE,CAAuB,CAAE,CAClD,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,OAAO,CAAG,GAAW,CAAC,EAC3B,MAAM,EAAO,IAAI,EAAW,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,OAAO,EACrD,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,aAAa,CAAC,GACrC,IAAI,CAAC,OAAO,CAAG,IAAI,EAAQ,aAAa,CAAC,GACzC,IAAI,CAAC,OAAO,CAAG,IAAI,EAAQ,aAAa,CAAC,GACzC,IAAI,CAAC,OAAO,CAAG,IAAI,EAAQ,aAAa,CAAC,GACzC,IAAI,CAAC,YAAY,CAAG,IAAI,EAAa,aAAa,CAAC,EACvD,CAOO,KAAK,CAAsB,CAAU,CACxC,OAAO,IAAI,EAAO,IAAI,CAAC,MAAM,CAAE,CAC3B,GAAG,IAAI,CAAC,OAAO,CACf,GAAG,CAAO,AACd,EACJ,CACJ,CAuPA,SAAS,EAAY,CAAW,CAAE,CAAU,EAC1C,GACmB,UAAjB,OAAO,GACP,EAAM,MAAM,EAAI,IAChB,EAAM,UAAU,CAAC,IAAM,IACvB,AAAuB,EADM,CACH,GAApB,EAD6B,CACH,OAAhB,CAAC,GACjB,CACA,IAAM,EAAa,IAAI,KAAK,GAC5B,GAAI,CAAC,MAAM,EAAW,OAAO,IAC3B,CADgC,MACzB,CAEX,CACA,OAAO,CACT,CAGA,SAAS,EAAY,CAAwC,EACzD,IAAM,EAAkB,EAAE,CAC1B,IAAK,IAAM,KAAO,EAEd,IAFqB,AAEhB,IAAM,KAAK,AADH,IACQ,EADF,OAAO,CAAC,CAAK,CAAC,EAAI,EAAK,CAAK,CAAC,EAAI,CAAG,CAAC,CAAK,CAAC,EAAI,CAAC,CAE/D,EAAM,IAAI,CAAC,CAAA,EAAG,EAAI,CAAC,EAAE,mBAAmB,GAAA,CAAI,EAGpD,OAAO,EAAM,IAAI,CAAC,IACtB,CAxOiB,IAAA,GAAA,CAAA,CAAA,CAAA,EAEA,aAAA,CAAN,EAAM,IAAA,AACD,UAAsB,AAE9B,aAAY,CAAsB,CAAE,CAChC,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EACzC,IAAI,CAAC,WAAW,CAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,EAC7C,IAAI,CAAC,SAAS,CAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EACzC,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EACvC,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EACvC,IAAI,CAAC,WAAW,CAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,EAC7C,IAAI,CAAC,KAAK,CAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CACrC,CAEA,MAAa,UAAU,CAA0D,CAAgE,CAE7I,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,aAAa,CAAC,CAAE,CAAC,OAAQ,OAAQ,KAAM,KAAK,SAAS,CAAC,EAAO,GAC9G,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CAEA,MAAa,YAAY,CAA8D,CAAoE,CAEvJ,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,eAAe,CAAC,CAAE,CAAC,OAAQ,OAAQ,KAAM,KAAK,SAAS,CAAC,EAAO,GAChH,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CAEA,MAAa,UAAU,CAA0D,CAAgE,CAE7I,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,aAAa,CAAC,CAAE,CAAC,OAAQ,OAAQ,KAAM,KAAK,SAAS,CAAC,EAAO,GAC9G,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CAEA,MAAa,SAAS,CAAwD,CAA8D,CAExI,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,aAAa,CAAC,CAAE,CAAC,OAAQ,OAAQ,KAAM,KAAK,SAAS,CAAC,EAAO,GAC9G,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CAEA,MAAa,UAAuE,CAEhF,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,YAAY,CAAC,CAAE,CAAC,OAAQ,MAAO,UAAM,CAAS,GAC/F,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CAEA,MAAa,aAAgF,CAEzF,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,eAAe,CAAC,CAAE,CAAC,OAAQ,MAAO,UAAM,CAAS,GAClG,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CAEA,MAAa,MAAM,CAAiD,CAAuD,CAEvH,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,YAAY,CAAC,CAAE,CAAC,OAAQ,OAAQ,KAAM,KAAK,SAAS,CAAC,EAAO,GAC7G,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CACJ,GAYa,GAAA,GAAA,CAAA,CAAA,CAAA,EAEA,aAAA,CAAN,EAAM,IAAA,AACD,UAAsB,AAE9B,aAAY,CAAsB,CAAE,CAChC,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CACvC,CAKA,MAAa,OAAO,CAAqD,CAA2D,CAEhI,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,QAAQ,CAAC,CAAE,CAAC,OAAQ,OAAQ,KAAM,KAAK,SAAS,CAAC,EAAO,GACzG,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CACJ,GASa,IAAA,EAAA,CAAA,CAAA,CAAA,EAEA,aAAA,CAAN,EAAM,IAAA,AACD,UAAsB,AAE9B,aAAY,CAAsB,CAAE,CAChC,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAC7B,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CACnC,CAKA,MAAa,IAAI,CAAsB,CAAqD,CAExF,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,SAAS,EAAE,mBAAmB,EAAO,EAAE,EAAA,CAAG,CAAE,CAAC,OAAQ,MAAO,UAAM,CAAS,GAC5H,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CAKA,MAAa,MAA4D,CAErE,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,QAAQ,CAAC,CAAE,CAAC,OAAQ,MAAO,KAAM,MAAS,GAC3F,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CACJ,EAUa,IAAA,GAAA,CAAA,CAAA,CAAA,EAEA,aAAA,CAAN,EAAM,IAAA,AACD,UAAsB,AAE9B,aAAY,CAAsB,CAAE,CAChC,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,YAAY,CAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAC/C,IAAI,CAAC,YAAY,CAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAC/C,IAAI,CAAC,cAAc,CAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CACvD,CAEA,MAAa,aAAa,CAAkE,CAAwE,CAEhK,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,eAAe,CAAC,CAAE,CAAC,OAAQ,OAAQ,KAAM,KAAK,SAAS,CAAC,EAAO,GAChH,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CAEA,MAAa,cAAqF,CAE9F,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,kBAAkB,CAAC,CAAE,CAAC,OAAQ,MAAO,UAAM,CAAS,GACrG,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CAEA,MAAa,eAAe,CAAsE,CAA4E,CAE1K,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,wBAAwB,CAAC,CAAE,CAAC,OAAQ,OAAQ,KAAM,KAAK,SAAS,CAAC,EAAO,GACzH,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CACJ,GAQa,IAAA,EAAA,CAAA,CAAA,CAAA,EAEA,aAAA,CAAN,EAAM,IAAA,AACD,UAAsB,AAE9B,aAAY,CAAsB,CAAE,CAChC,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CACnC,CAKA,MAAa,MAAiE,CAE1E,IAAM,EAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,aAAa,CAAC,CAAE,CAAC,OAAQ,MAAO,UAAM,CAAS,GAChG,OAAO,KAAK,KAAK,CAAC,MAAM,EAAK,IAAI,GAAI,EACzC,CACJ,CAuFJ,OAAM,EACK,EAAc,CAEb,kBAAoC,EAAE,AAAC,AAE/C,aAAY,CAAW,CAAE,CAAgC,CAAE,CACvD,IAAI,EAAY,CAAC,YAAY,CACzB,GACA,EAAU,IADD,AACK,CAXf,AAWgB,sBAfD,EAIS,GAJJ,KAAK,SAAS,CAeK,AAfJ,IACvC,UAAU,CAAC,IAAK,IAChB,UAAU,CAAC,IAAK,KAChB,UAAU,CAAC,IAAK,MAef,IAAI,CAAC,EAAE,CAAG,IAAI,UAAU,EAAK,GAE7B,IAAI,CAAC,EAAE,CAAC,QAAS,KACb,IAAI,CAAC,wBAAwB,EACjC,GAEA,IAAI,CAAC,EAAE,CAAC,QAAS,KACb,IAAI,CAAC,wBAAwB,EACjC,EACJ,CAEA,0BAA2B,CACvB,IAAM,EAAW,IAAI,CAAC,iBAAiB,CAGvC,IAAK,IAAM,KAFX,IAAI,CAAC,iBAAiB,CAAG,EAAE,CAEL,GAClB,GAER,CAEA,EALoC,IAK9B,WAAY,CAEd,MAAM,IAAI,QAAQ,AAAC,IACf,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAM,EAAQ,MAC9C,EACJ,CAEA,GAAG,CAA4C,CAAE,CAA6B,CAAE,CAC5E,IAAI,CAAC,EAAE,CAAC,gBAAgB,CAAC,EAAM,EACnC,CAEA,IAAI,CAA4C,CAAE,CAA6B,CAAE,CAC7E,IAAI,CAAC,EAAE,CAAC,mBAAmB,CAAC,EAAM,EACtC,CAEA,OAAQ,CACJ,IAAI,CAAC,EAAE,CAAC,KAAK,EACjB,CACJ,CAEO,MAAM,EACF,MAA4B,CAC3B,OAAqB,EAAE,AAAC,AAEhC,aAAY,CAAW,CAAE,CAAgC,CAAE,CACvD,IAAI,CAAC,MAAM,CAAG,IAAI,EAAoB,EAAK,GAC3C,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,UAAW,AAAC,IACvB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAM,IAAI,CAAE,IACxC,IAAI,CAAC,MAAM,CAAC,wBAAwB,EACxC,EACJ,CAEA,OAAQ,CACJ,IAAI,CAAC,MAAM,CAAC,KAAK,EACrB,CAEA,MAAM,KAAK,CAAY,CAAE,CAQrB,OAPI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,UAAU,GAAK,UAAU,UAAU,EAAE,AAEpD,MAAM,IAAI,QAAQ,AAAC,IACf,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,gBAAgB,CAAC,OAAQ,EAAS,CAAE,MAAM,CAAK,EAClE,GAGG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC,GAC9C,CAEA,MAAM,MAAsC,CACxC,UAAW,IAAM,KAAQ,IAAI,CAAE,OAAO,CAE1C,CAEA,OAAO,CAAC,OAAO,aAAa,CAAC,EAA8C,CACvE,MAAO,CACH,GAAI,CADK,GACD,CAAC,MAAM,CAAC,MAAM,CAAG,EACrB,CADwB,KAClB,IAAI,CAAC,MAAM,CAAC,KAAK,OACpB,CACH,GAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,UAAU,GAAK,UAAU,MAAM,CAAE,MACpD,OAAM,IAAI,CAAC,MAAM,CAAC,SAAS,EAC/B,CAER,CACJ,CAEO,MAAM,EACF,MAA4B,CAC3B,OAAqB,EAE7B,AAFgC,AAAD,aAEnB,CAAW,CAAE,CAAgC,CAAE,CACvD,IAAI,CAAC,MAAM,CAAG,IAAI,EAAoB,EAAK,GAC3C,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,UAAW,AAAC,IACvB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAM,IAAI,CAAE,IACxC,IAAI,CAAC,MAAM,CAAC,wBAAwB,EACxC,EACJ,CAEA,OAAQ,CACJ,IAAI,CAAC,MAAM,CAAC,KAAK,EACrB,CAEA,MAAM,MAAsC,CACxC,UAAW,IAAM,KAAQ,IAAI,CAAE,OAAO,CAE1C,CAEA,OAAO,CAAC,OAAO,aAAa,CAAC,EAA8C,CACvE,MAAO,CACH,GAAI,CADK,GACD,CAAC,MAAM,CAAC,MAAM,CAAG,EACrB,CADwB,KAClB,IAAI,CAAC,MAAM,CAAC,KAAK,OACpB,CACH,GAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,UAAU,GAAK,UAAU,MAAM,CAAE,MACpD,OAAM,IAAI,CAAC,MAAM,CAAC,SAAS,EAC/B,CAER,CACJ,CAEO,MAAM,EACF,MAA4B,CAC3B,aAAiC,AAEzC,aAAY,CAAW,CAAE,CAAgC,CAAE,CACvD,IAAI,EACJ,IAAI,CAAC,aAAa,CAAG,IAAI,QAAQ,AAAC,GAAY,EAAmB,GAEjE,IAAI,CAAC,MAAM,CAAG,IAAI,EAAoB,EAAK,GAC3C,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,UAAW,AAAC,IACvB,EAAiB,KAAK,KAAK,CAAC,EAAM,IAAI,CAAE,GAC5C,EACJ,CAEA,MAAM,UAA8B,CAChC,OAAO,IAAI,CAAC,aAAa,AAC7B,CAEA,OAAQ,CACJ,IAAI,CAAC,MAAM,CAAC,KAAK,EACrB,CAEA,MAAM,KAAK,CAAY,CAAE,CAQrB,OAPI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,UAAU,GAAK,UAAU,UAAU,EAAE,AAEpD,MAAM,IAAI,QAAQ,AAAC,IACf,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,gBAAgB,CAAC,OAAQ,EAAS,CAAE,MAAM,CAAK,EAClE,GAGG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC,GAC9C,CACJ,CAmBA,IAAM,EAAa,MAAM,IAAI,QAE7B,OAAM,EACO,OAAe,AACf,QAAgB,CAChB,OAA+B,CAC/B,WAAgF,CAChF,aAAiC,AAE1C,aAAY,CAAe,CAAE,CAAsB,CAAE,CAoBjD,GAnBA,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,OAAO,CAAG,CAAC,EAIZ,AAAC,GACD,KAAI,CADM,AACL,OAAO,CAAC,aAAa,CAAG,sCAAA,EAGjC,IAAI,CAAC,WAAW,CAAG,EAAQ,WAAW,EAAI,CAAC,OAGnB,IAApB,EAAQ,KAAuB,EAAhB,CACf,IAAI,CAAC,OAAO,CAAG,EAAQ,OAAO,CAE9B,IAAI,CAAC,OAAO,CAAG,OAIE,IAAjB,EAAQ,IAAI,CAAgB,CAC5B,MAAM,EAAO,EAAQ,IAAI,CACL,YAAhB,AAA4B,OAArB,EACP,IAAI,CAAC,aAAa,CAAG,EAErB,IAAI,CAAC,aAAa,CAAG,IAAM,CAEnC,CACJ,CAEA,MAAM,aAAmD,CACrD,IAAI,EAGJ,GAAI,IAAI,CAAC,aAAa,CAAE,CACpB,IAAM,EAAe,IAAI,CAAC,aAAa,GAEnC,EADA,aAAwB,QACb,CADsB,KAChB,EAEN,CAEnB,CAEA,GAAI,EAAU,CACV,IAAM,EAAuB,CAAC,EAM9B,OAJA,EAAK,OAAO,CAAG,AAjR3B,SAA2D,AAAlD,CAAkF,EACvF,IAAK,IAAM,KAAO,OACM,AADE,IAClB,CAAM,CAAC,EAAI,EACX,CAD2B,MACpB,CAAM,CAAC,EAAI,CAG1B,OAAO,CACX,EA0QsD,CACtC,cAAe,EAAS,aAAa,AACzC,GAEO,CACX,CAGJ,CAGA,MAAM,kBAAqC,CAAY,CAAE,CAAuB,CAA2C,CACvH,GAAI,OAAE,CAAK,SAAE,CAAO,CAAE,CAAG,GAAU,CAAC,EAG9B,EAAW,MAAM,IAAI,CAAC,WAAW,GAGnC,IACI,EAAS,IADH,CACQ,EAAE,CAChB,EAAQ,CAAC,GAAG,CAAK,CAAE,GAAG,EAAS,KAAK,CAAA,EAEpC,EAAS,OAAO,EAAE,AAClB,GAAU,CAAC,GAAG,CAAO,CAAE,GAAG,EAAS,OAAO,CAAA,GAIlD,IAAM,EAAc,EAAQ,IAAM,EAAY,GAAS,GACvD,OAAO,IAAI,EAAY,IAAI,CAAC,OAAO,CAAG,EAAO,EAAa,EAC9D,CAGA,MAAM,eAAyB,CAAY,CAAE,CAAuB,CAA+B,CAC/F,GAAI,CAAE,OAAK,SAAE,CAAO,CAAE,CAAG,GAAU,CAAC,EAG9B,EAAW,MAAM,IAAI,CAAC,WAAW,GAGnC,IACI,EAAS,IADH,CACQ,EAAE,CAChB,EAAQ,CAAC,GAAG,CAAK,CAAE,GAAG,EAAS,KAAK,CAAA,EAEpC,EAAS,OAAO,EAAE,CAClB,EAAU,CAAC,GAAG,CAAO,CAAE,GAAG,EAAS,OAAO,CAAA,GAIlD,IAAM,EAAc,EAAQ,IAAM,EAAY,GAAS,GACvD,OAAO,IAAI,EAAS,IAAI,CAAC,OAAO,CAAG,EAAO,EAAa,EAC3D,CAGA,MAAM,gBAAmC,CAAY,CAAE,CAAuB,CAAyC,CACnH,GAAI,OAAE,CAAK,SAAE,CAAO,CAAE,CAAG,GAAU,CAAC,EAG9B,EAAW,MAAM,IAAI,CAAC,WAAW,GAGnC,IACI,EAAS,IADH,CACQ,EAAE,CAChB,EAAQ,CAAC,GAAG,CAAK,CAAE,GAAG,EAAS,KAAK,CAAA,EAEpC,EAAS,OAAO,EAAE,CAClB,EAAU,CAAC,GAAG,CAAO,CAAE,GAAG,EAAS,OAAO,CAAA,GAIlD,IAAM,EAAc,EAAQ,IAAM,EAAY,GAAS,GACvD,OAAO,IAAI,EAAU,IAAI,CAAC,OAAO,CAAG,EAAO,EAAa,EAC5D,CAGA,MAAa,aAAa,CAAY,CAAE,CAAuB,CAAqB,CAChF,OAAO,IAAI,CAAC,OAAO,CAAC,EAAM,CACtB,GAAG,CAAM,CACT,QAAS,CAAE,eAAgB,mBAAoB,GAAG,GAAQ,OAAO,AAAC,CACtE,EACJ,CAGA,MAAa,QAAQ,CAAY,CAAE,CAAuB,CAAqB,CAC3E,GAAI,OAAE,CAAK,SAAE,CAAO,CAAE,GAAG,EAAM,CAAG,GAAU,CAAC,EACvC,EAAO,CACT,GAAG,IAAI,CAAC,WAAW,CACnB,GAAG,CAAI,AACX,CAGA,GAAK,OAAO,CAAG,CAAC,GAAG,IAAI,CAAC,OAAO,CAAE,GAAG,EAAK,OAAO,CAAE,GAAG,CAAO,EAG5D,IAAM,EAAW,MAAM,IAAI,CAAC,WAAW,GAGnC,IACI,EAAS,IADH,CACQ,EAAE,CAChB,EAAQ,CAAC,GAAG,CAAK,CAAE,GAAG,EAAS,KAAK,CAAA,EAEpC,EAAS,OAAO,EAAE,AAClB,GAAK,OAAO,CAAG,CAAC,GAAG,EAAK,OAAO,CAAE,GAAG,EAAS,OAAO,CAAA,GAK5D,IAAM,EAAc,EAAQ,IAAM,EAAY,GAAS,GACjD,EAAW,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,EAAK,EAAa,GAGnE,GAAI,CAAC,EAAS,EAAE,CAAE,CAEd,IAAI,EAAyB,CAAE,IAAI,CAAA,UAAmB,QAAS,CAAC,uBAAuB,EAAE,EAAS,MAAM,CAAA,CAAE,AAAC,EAG3G,GAAI,CACA,IAAM,EAAO,MAAM,EAAS,IAAI,GAEhC,GAAI,KA+BQ,GAAQ,CA9BhB,IAAM,EAAW,KAAK,KAAK,CAAC,MACL,QA+BnC,GA/B8C,CAsCnC,EAND,EADF,AACM,AAMM,IANF,CAON,AAAT,QARkB,IAQI,IARI,GAQG,KAPhC,CAOsC,CAAC,GAAS,QAAQ,CAAC,KANjC,UAAxB,EACA,KADO,EAAI,OAAO,QACD,IAAhB,EAAI,OAAO,EAAkC,OAAhB,EAAI,OAAO,EAAqC,UAAxB,OAAO,EAAI,OAAO,AAAM,CAAQ,EAjCtE,EAAO,EAEP,EAAK,OAAO,EAAI,KAAO,KAAK,SAAS,CAAC,EAE9C,CAAE,KAAM,CACJ,EAAK,OAAO,EAAI,KAAO,CAC3B,CACJ,CAAE,MAAO,EAAG,CAER,EAAK,OAAO,EAAI,KAAO,OAAO,EAClC,CAEA,MAAM,IAAI,EAAS,EAAS,MAAM,CAAE,EACxC,CAEA,OAAO,CACX,CACJ,CA2BO,MAAM,UAAiB,MAIV,MAAc,CAKd,IAAa,CAKb,OAAa,AAE7B,aAAY,CAAc,CAAE,CAA0B,CAAE,CAEpD,KAAK,CAAC,EAAS,OAAO,EAItB,OAAO,cAAc,CAAC,IAAI,CAAE,OAAQ,CAChC,MAAc,WACd,YAAc,EACd,cAAc,CAClB,QAGsC,GAAjC,OAAe,CAA6B,aAAf,CAC7B,IAAI,CAAS,SAAS,CAAG,EAAS,SAAS,CAE5C,OAAO,cAAc,CAAC,IAAI,CAAE,EAAS,SAAS,OAIT,IAApC,MAAc,CAAiC,gBAAhB,EAC/B,MAAc,iBAAiB,CAAC,IAAI,CAAE,IAAI,CAAC,WAAW,EAG3D,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,IAAI,CAAG,EAAS,IAAI,CACzB,IAAI,CAAC,OAAO,CAAG,EAAS,OAAO,AACnC,CACJ,CASO,gBAAK,GAGP,CAHO,MAGP,EAAA,CAAA,KAOA,EAAA,QAAA,CAAA,WAWA,EAAA,OAAA,CAAA,UAUA,EAAA,eAAA,CAAA,mBAYA,EAAA,gBAAA,CAAA,oBAQA,EAAA,QAAA,CAAA,YAQA,EAAA,aAAA,CAAA,iBAaA,EAAA,gBAAA,CAAA,oBAUA,EAAA,iBAAA,CAAA,qBAyBA,EAAA,kBAAA,CAAA,sBAUA,EAAA,OAAA,CAAA,UAqBA,EAAA,UAAA,CAAA,eAYA,EAAA,aAAA,CAAA,gBAUA,EAAA,QAAA,CAAA,WAcA,EAAA,WAAA,CAAA,cAOA,EAAA,QAAA,CAAA,YAUA,EAAA,eAAA,CAAA,kBA/LO,SAyMG,IAAI,EALjB,EAAY,GAAG,AAKS,CALR,YAAY,EAC5B,EAAY,GAAG,CAAC,iBAAiB,EACjC,EAAY,GAAG,CAAC,kBAAkB,EAjgCN,EAkgC5B,sBAEyC,CACzC,YAAa,CAAE,YAAa,SAAU,CACxC"}